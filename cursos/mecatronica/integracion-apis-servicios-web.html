<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Integración con APIs y Servicios Web</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <!-- Bootstrap Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  <!-- Prism.js CSS Tema Dark -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <!-- Custom CSS -->
  <link rel="stylesheet" href="../../css/styles.css">

</head>

<body class="bg-light">
  <div class="container mt-5">
    <!-- Breadcrumb Navigation -->
    <nav aria-label="breadcrumb">
      <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="../../index.html">Inicio</a></li>
        <li class="breadcrumb-item"><a href="../fundamentos-de-mecatronica.html">Fundamentos de Mecatrónica</a></li>
        <li class="breadcrumb-item active" aria-current="page">Integración con APIs y Servicios Web</li>
      </ol>
    </nav>

    <header class="p-5 mb-4 bg-white rounded-3 shadow-sm text-center">
      <h1 class="display-5 fw-bold">Bloque 4.3: Integración con APIs y Servicios Web</h1>
      <p class="fs-4">Llevando tus proyectos IoT al siguiente nivel conectándolos con el mundo digital.</p>
    </header>

    <!-- Slides banner -->
    <div class="row">
      <div class="col-lg-8 mx-auto">
        <div class="alert alert-primary d-flex align-items-center mb-3 shadow-sm" role="alert">
          <i class="bi bi-easel2-fill fs-3 me-3"></i>
          <div class="flex-grow-1">
            <h4 class="alert-heading">Diapositivas del Tema</h4>
            <p class="mb-0">Consulta la presentación visual de este tema para una mejor comprensión de los conceptos.
            </p>
          </div>
          <a href="#" class="btn btn-primary ms-3" target="_blank" rel="noopener noreferrer">Ver Presentación &rarr;</a>
        </div>
        <div class="alert alert-info d-flex align-items-center mb-5 shadow-sm" role="alert">
          <i class="bi bi-globe fs-3 me-3"></i>
          <div>
            <h4 class="alert-heading">Del Dispositivo Local a la Nube</h4>
            <p class="mb-0">Hasta ahora, hemos visto cómo los dispositivos pueden comunicarse entre sí (por ejemplo, con
              MQTT). Ahora veremos cómo pueden interactuar con poderosas aplicaciones y servicios alojados en internet,
              como bases de datos, servicios de clima, redes sociales o plataformas de análisis, a través de APIs.</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Content -->
    <div class="row">
      <div class="col-lg-8 mx-auto">
        <article class="blog-post">
          <section class="mb-5">

            <h2 class="text-primary border-bottom pb-2 mb-4">1. ¿Qué es una API?</h2>
            <p>API son las siglas de <strong>Application Programming Interface</strong> (Interfaz de Programación de
              Aplicaciones). En términos simples, una API es un conjunto de reglas y definiciones que permite que dos
              aplicaciones o sistemas se comuniquen entre sí.</p>
            <p>Imagina una API como un mesero en un restaurante. Tú (el cliente) le dices al mesero (la API) lo que
              quieres
              del menú (los datos o una acción). El mesero lleva tu pedido a la cocina (el servidor/backend), la cocina
              prepara lo que pediste, y el mesero te trae la comida (la respuesta) de vuelta. Tú no necesitas saber cómo
              se
              prepara la comida, solo necesitas saber cómo pedirla.</p>

            <h3 class="mt-4">1.1. Analogía: La API como Cajero Automático (ATM)</h3>
            <figure class="text-center my-4">
              <img src="https://placehold.co/700x400?text=Analogía+API+Cajero+Automático"
                class="img-fluid rounded shadow-sm" alt="Analogía de una API con un cajero automático">
              <figcaption class="figure-caption mt-2">Una API como un cajero automático: tú interactúas con una interfaz
                simple para obtener un servicio complejo (sacar dinero de tu cuenta bancaria).</figcaption>
            </figure>
            <p>Para usar un cajero automático:</p>
            <ol>
              <li><strong>Interfaz Común:</strong> Todos los cajeros tienen botones y una pantalla similares. Sabes
                intuitivamente cómo insertar la tarjeta, ingresar el PIN y seleccionar "Retiro". Esta interfaz
                estandarizada
                es como una API.</li>
              <li><strong>Reglas Definidas:</strong> Solo puedes retirar dinero si tienes fondos. El cajero no te
                permite
                simplemente tomar dinero; sigue reglas estrictas. Una API también tiene reglas sobre qué solicitudes
                puede
                aceptar y cómo deben formularse.</li>
              <li><strong>Intermediario:</strong> El cajero no almacena tu dinero. Se comunica con el banco (el
                servidor)
                para verificar tu saldo y autorizar la transacción.</li>
              <li><strong>Respuesta Estructurada:</strong> Si la transacción es exitosa, recibes dinero en efectivo (la
                respuesta). Si hay un error, el cajero muestra un mensaje de error en la pantalla.</li>
            </ol>

            <h3 class="mt-4">1.2. Tipos Comunes de APIs</h3>
            <div class="row">
              <div class="col-md-6">
                <h5>REST APIs</h5>
                <p>REST (REpresentational State Transfer) es el estilo arquitectónico más popular para diseñar APIs web.
                  Se
                  basa en el protocolo HTTP.</p>
                <ul>
                  <li><strong>Verbos HTTP:</strong> Usa verbos estándar como <code>GET</code> (obtener),
                    <code>POST</code>
                    (crear), <code>PUT</code> (actualizar), <code>DELETE</code> (eliminar).</li>
                  <li><strong>Endpoints:</strong> Cada recurso tiene una URL única (endpoint), por ejemplo:
                    <code>https://api.ejemplo.com/usuarios/123</code>.
                  </li>
                  <li><strong>Formatos de Datos:</strong> Los datos se intercambian comúnmente en formatos como JSON o
                    XML.
                  </li>
                  <li><strong>Sin estado (Stateless):</strong> Cada solicitud es independiente y contiene toda la
                    información necesaria.</li>
                </ul>
              </div>
              <div class="col-md-6">
                <h5>SOAP APIs</h5>
                <p>SOAP (Simple Object Access Protocol) es un protocolo más estricto y basado en XML.</p>
                <ul>
                  <li><strong>Más Complejo:</strong> Tiene una estructura más rígida y requiere más ancho de banda.</li>
                  <li><strong>Seguridad Integrada:</strong> Ofrece estándares de seguridad más robustos y transacciones
                    ACID.</li>
                  <li><strong>Menos Popular:</strong> Para aplicaciones web y móviles modernas, REST es generalmente
                    preferido por su simplicidad.</li>
                </ul>
              </div>
            </div>
            <p>En el contexto de IoT y microcontroladores, las <strong>REST APIs</strong> son las más utilizadas debido
              a su
              simplicidad y eficiencia.</p>

            <hr class="my-4">

            <h2 class="text-primary border-bottom pb-2 mb-4">2. APIs y Servicios Web en el Contexto de un ESP32</h2>
            <p>Cuando hablamos de un microcontrolador ESP32 "usando una API", normalmente nos referimos a que el ESP32
              actúa
              como un cliente HTTP que hace solicitudes a un servidor web (el backend de una aplicación o servicio) que
              expone una API REST.</p>

            <h3 class="mt-4">2.1. El ESP32 como Cliente Web</h3>
            <p>El ESP32 tiene conectividad WiFi integrada, lo que le permite conectarse a internet. Utilizando librerías
              como <code>HTTPClient</code> (incluida en el núcleo de ESP32 para Arduino), puede enviar solicitudes HTTP
              <code>GET</code>, <code>POST</code>, <code>PUT</code>, etc. a un servidor web.
            </p>
            <figure class="text-center my-4">
              <img src="https://placehold.co/800x400?text=Diagrama+ESP32+API+Cliente"
                class="img-fluid rounded shadow-sm" alt="Diagrama del ESP32 actuando como cliente de una API web">
              <figcaption class="figure-caption mt-2">El ESP32 puede conectarse a internet y actuar como un cliente que
                consume servicios de APIs web.</figcaption>
            </figure>

            <h3 class="mt-4">2.2. ¿Por qué Integrar con APIs/Servicios Web?</h3>
            <p>Conectar tu ESP32 a servicios web abre un mundo de posibilidades:</p>
            <ul>
              <li><strong>Almacenamiento de Datos:</strong> En lugar de almacenar datos localmente (con poca capacidad),
                puedes enviarlos a una base de datos en la nube (como Firebase, MySQL remoto).</li>
              <li><strong>Visualización de Datos:</strong> Usar servicios como ThingSpeak, Ubidots o Grafana para crear
                dashboards en tiempo real.</li>
              <li><strong>Acceso Remoto:</strong> Controlar tu ESP32 desde cualquier lugar del mundo a través de una
                aplicación web que se comunique con él (a menudo a través de un broker MQTT o un servidor intermedio).
              </li>
              <li><strong>Integración con Otros Servicios:</strong>
                <ul>
                  <li>Enviar un correo electrónico o un mensaje de Slack cuando un sensor detecta una condición
                    específica.
                  </li>
                  <li>Obtener datos del clima para ajustar el comportamiento de un sistema de riego.</li>
                  <li>Consultar el precio actual de la electricidad para programar el uso de electrodomésticos.</li>
                </ul>
              </li>
              <li><strong>Machine Learning/IA:</strong> Enviar datos a servicios de análisis en la nube para detectar
                patrones o anomalías.</li>
            </ul>

            <h3 class="mt-4">2.3. Ejemplo Conceptual: Sistema de Alerta de Clima</h3>
            <p>Imagina un sistema que monitorea la temperatura con un ESP32 y envía una alerta si la temperatura supera
              un
              umbral.</p>
            <ol>
              <li>El ESP32 lee el sensor de temperatura.</li>
              <li>Si la temperatura es alta, el ESP32 hace una solicitud <code>POST</code> a una API web personalizada
                (por
                ejemplo, <code>https://mi-api-alertas.com/enviar_alerta</code>) con los datos de la temperatura.</li>
              <li>El servidor de la API recibe la solicitud, procesa los datos y envía un correo electrónico o
                notificación
                push a través de otro servicio (como SendGrid o Firebase Cloud Messaging).</li>
            </ol>
            <p>En este escenario, la API web actúa como intermediaria y punto de integración entre el dispositivo físico
              (ESP32) y el servicio de notificación (correo/telefono).</p>

            <hr class="my-4">

            <h2 class="text-primary border-bottom pb-2 mb-4">3. Realizando Solicitudes HTTP desde un ESP32</h2>
            <p>Veamos cómo se hace esto en la práctica con el ESP32 y el entorno de Arduino. La librería
              <code>HTTPClient</code> simplifica enormemente el proceso.
            </p>

            <h3 class="mt-4">3.1. Haciendo una Solicitud GET Simple</h3>
            <p>Una solicitud <code>GET</code> se usa típicamente para <strong>obtener</strong> datos de un servidor. Un
              ejemplo común es consultar un servicio de clima.</p>

            <h5 class="mt-3">Materiales Necesarios</h5>
            <ul>
              <li>1 Placa ESP32 (NodeMCU, DevKit, etc.)</li>
            </ul>

            <h5 class="mt-3">Código del Sketch (Ejemplo de GET)</h5>
            <p>Este ejemplo consulta una API pública que devuelve un JSON con un "hecho" aleatorio sobre gatos.</p>
            <pre class="code-container"><button class="btn btn-outline-light btn-sm btn-copy-code" onclick="copyCodePrism(this)" aria-label="Copiar código"><i class="bi bi-clipboard"></i> Copiar</button><code class="language-cpp" id="http-get-code">/*
 * Ejemplo de Solicitud HTTP GET con ESP32
 * Consulta una API pública de hechos de gatos.
 */

#include &lt;WiFi.h&gt;
#include &lt;HTTPClient.h&gt;

// --- Configuración de WiFi ---
const char* ssid = "TU_SSID";
const char* password = "TU_CONTRASEÑA";

void setup() {
  Serial.begin(115200);
  delay(1000); // Breve pausa antes de comenzar

  // Conectamos a la red WiFi
  Serial.print("Conectando a ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println("¡Conectado a la red WiFi!");
  Serial.print("Dirección IP: ");
  Serial.println(WiFi.localIP());
}

void loop() {
  // Verificamos que estemos conectados
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;

    // 1. Especificamos el servidor y el endpoint
    http.begin("http://catfact.ninja/fact"); // URL de la API

    // 2. Enviamos la solicitud GET
    int httpResponseCode = http.GET();

    // 3. Procesamos la respuesta
    if (httpResponseCode > 0) {
      Serial.print("Código de respuesta HTTP: ");
      Serial.println(httpResponseCode);

      if (httpResponseCode == 200) { // 200 = OK
        // 4. Obtenemos el cuerpo de la respuesta
        String payload = http.getString();
        Serial.println("Respuesta JSON:");
        Serial.println(payload);
        Serial.println("--------------------");
      }
    } else {
      Serial.print("Error en la solicitud GET. Código: ");
      Serial.println(httpResponseCode);
    }

    // 5. Cerramos la conexión
    http.end();
  } else {
    Serial.println("Error: No conectado a WiFi");
  }

  // Esperamos 10 segundos antes de la próxima solicitud
  delay(10000);
}</code></pre>

            <h5 class="mt-3">Explicación del Código</h5>
            <ul>
              <li><strong>Conexión WiFi:</strong> Igual que en ejemplos anteriores, conectamos el ESP32 a la red.</li>
              <li><code>#include &lt;HTTPClient.h&gt;</code>: Incluimos la librería necesaria para hacer solicitudes
                HTTP.
              </li>
              <li><code>HTTPClient http;</code>: Creamos un objeto <code>HTTPClient</code> para manejar la solicitud.
              </li>
              <li><code>http.begin("URL");</code>: Inicializamos el cliente HTTP con la URL del endpoint de la API.</li>
              <li><code>int httpResponseCode = http.GET();</code>: Enviamos la solicitud <code>GET</code> y almacenamos
                el
                código de respuesta HTTP (200 para éxito, 404 para no encontrado, etc.).</li>
              <li><code>if (httpResponseCode == 200)</code>: Verificamos si la solicitud fue exitosa.</li>
              <li><code>String payload = http.getString();</code>: Si fue exitosa, obtenemos el cuerpo de la respuesta
                como
                un <code>String</code>.</li>
              <li><code>http.end();</code>: Es crucial cerrar la conexión HTTP después de usarla para liberar recursos.
              </li>
            </ul>
            <p>La respuesta de esta API es un string JSON como:
              <code>{"fact":"Los gatos duermen entre 12 y 16 horas al día.","length":49}</code>.
            </p>

            <h3 class="mt-4">3.2. Haciendo una Solicitud POST para Enviar Datos</h3>
            <p>Una solicitud <code>POST</code> se usa típicamente para <strong>enviar</strong> datos al servidor, como
              los
              valores de sensores.</p>

            <h5 class="mt-3">Código del Sketch (Ejemplo de POST)</h5>
            <p>Este ejemplo envía una lectura de temperatura simulada a un servicio web. Para este ejemplo, usaremos un
              servicio de prueba como <a href="https://httpbin.org/" target="_blank">httpbin.org</a> que simplemente
              devuelve lo que le enviamos.</p>
            <pre class="code-container"><button class="btn btn-outline-light btn-sm btn-copy-code" onclick="copyCodePrism(this)" aria-label="Copiar código"><i class="bi bi-clipboard"></i> Copiar</button><code class="language-cpp" id="http-post-code">/*
 * Ejemplo de Solicitud HTTP POST con ESP32
 * Envía datos simulados de un sensor a un servicio web.
 */

#include &lt;WiFi.h&gt;
#include &lt;HTTPClient.h&gt;

// --- Configuración de WiFi ---
const char* ssid = "TU_SSID";
const char* password = "TU_CONTRASEÑA";

void setup() {
  Serial.begin(115200);
  delay(1000);

  // Conectamos a la red WiFi
  Serial.print("Conectando a ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println("¡Conectado a la red WiFi!");
}

void loop() {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;

    // 1. Especificamos el endpoint POST
    http.begin("https://httpbin.org/post");

    // 2. (Opcional) Establecemos encabezados
    http.addHeader("Content-Type", "application/json");

    // 3. Preparamos los datos a enviar (en formato JSON)
    // Simulamos una lectura de sensor
    float temperatura = 22.5 + (random(0, 100) / 10.0); // Valor entre 22.5 y 32.5
    String jsonPayload = "{\"sensor\":\"DHT22\",\"temperatura\":" + String(temperatura, 2) + ",\"unidad\":\"Celsius\"}";

    Serial.print("Enviando datos: ");
    Serial.println(jsonPayload);

    // 4. Enviamos la solicitud POST con los datos
    int httpResponseCode = http.POST(jsonPayload);

    // 5. Procesamos la respuesta
    if (httpResponseCode > 0) {
      Serial.print("Código de respuesta HTTP: ");
      Serial.println(httpResponseCode);

      if (httpResponseCode == 200) {
        String response = http.getString();
        Serial.println("Respuesta del servidor:");
        Serial.println(response);
        Serial.println("--------------------");
      }
    } else {
      Serial.print("Error en la solicitud POST. Código: ");
      Serial.println(httpResponseCode);
    }

    // 6. Cerramos la conexión
    http.end();
  } else {
    Serial.println("Error: No conectado a WiFi");
  }

  // Esperamos 15 segundos antes de la próxima solicitud
  delay(15000);
}</code></pre>

            <h5 class="mt-3">Explicación del Código</h5>
            <ul>
              <li><code>http.addHeader("Content-Type", "application/json");</code>: Antes de enviar el
                <code>POST</code>,
                añadimos un encabezado indicando que el contenido es JSON. Esto es importante para que el servidor sepa
                cómo
                interpretar los datos.</li>
              <li><code>String jsonPayload = ...</code>: Creamos un string en formato JSON con los datos del sensor. Es
                crucial formatearlo correctamente.</li>
              <li><code>int httpResponseCode = http.POST(jsonPayload);</code>: Enviamos la solicitud <code>POST</code>,
                pasando el string con los datos como argumento. La librería se encarga de calcular la longitud del
                contenido
                y enviarlo en el cuerpo de la solicitud.</li>
            </ul>
            <p>Este ejemplo demuestra cómo un dispositivo puede "publicar" sus datos en un servicio web para su
              posterior
              procesamiento, almacenamiento o análisis.</p>

            <h3 class="mt-4">3.3. Manejo de Respuestas JSON</h3>
            <p>Las APIs suelen devolver datos en formato JSON. Aunque podemos imprimir el string JSON completo, es más
              útil
              poder extraer valores específicos. Para esto, se pueden usar librerías como <code>ArduinoJson</code>.</p>

            <h5 class="mt-3">Instalando ArduinoJson</h5>
            <p>Ve al <strong>Gestor de Librerías</strong> del Arduino IDE (Herramientas > Administrar Bibliotecas...) y
              busca e instala <code>ArduinoJson</code> por Benoit Blanchon.</p>

            <h5 class="mt-3">Código del Sketch (Parseando JSON)</h5>
            <p>Modificamos el ejemplo de <code>GET</code> para extraer solo el "hecho" del JSON recibido.</p>
            <pre class="code-container"><button class="btn btn-outline-light btn-sm btn-copy-code" onclick="copyCodePrism(this)" aria-label="Copiar código"><i class="bi bi-clipboard"></i> Copiar</button><code class="language-cpp" id="json-parse-code">/*
 * Ejemplo de Parseo de JSON con ESP32 y ArduinoJson
 * Extrae información de una respuesta JSON de la API de hechos de gatos.
 */

#include &lt;WiFi.h&gt;
#include &lt;HTTPClient.h&gt;
#include &lt;ArduinoJson.h&gt; // Incluimos la librería ArduinoJson

// --- Configuración de WiFi ---
const char* ssid = "TU_SSID";
const char* password = "TU_CONTRASEÑA";

void setup() {
  Serial.begin(115200);
  delay(1000);

  Serial.print("Conectando a ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println("¡Conectado a la red WiFi!");
}

void loop() {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    http.begin("http://catfact.ninja/fact");

    int httpResponseCode = http.GET();

    if (httpResponseCode > 0 && httpResponseCode == 200) {
      String payload = http.getString();
      Serial.println("JSON Recibido: " + payload);

      // --- Parseo del JSON ---
      // 1. Creamos un documento JSON. El tamaño debe ser suficiente para la respuesta.
      //    Puedes usar la herramienta de ArduinoJson: https://arduinojson.org/v6/assistant/
      DynamicJsonDocument doc(1024); 

      // 2. Deserializamos el string JSON en el documento
      DeserializationError error = deserializeJson(doc, payload);

      if (error) {
        Serial.print("Error de deserialización: ");
        Serial.println(error.f_str());
        return;
      }

      // 3. Extraemos los valores
      const char* fact = doc["fact"]; // Obtiene el valor de la clave "fact"
      int length = doc["length"];     // Obtiene el valor de la clave "length"

      // 4. Imprimimos los valores extraídos
      Serial.println("--- Datos Extraídos ---");
      Serial.print("Hecho: ");
      Serial.println(fact);
      Serial.print("Longitud: ");
      Serial.println(length);
      Serial.println("----------------------");

    } else {
      Serial.print("Error en la solicitud GET. Código: ");
      Serial.println(httpResponseCode);
    }

    http.end();
  } else {
    Serial.println("Error: No conectado a WiFi");
  }

  delay(15000);
}</code></pre>

            <h5 class="mt-3">Explicación del Código</h5>
            <ul>
              <li><code>#include &lt;ArduinoJson.h&gt;</code>: Incluimos la librería ArduinoJson.</li>
              <li><code>DynamicJsonDocument doc(1024);</code>: Creamos un documento JSON con un tamaño estimado (1024
                bytes). Para aplicaciones más complejas, puedes usar la <a href="https://arduinojson.org/v6/assistant/"
                  target="_blank">herramienta de asistente</a> de ArduinoJson para calcular el tamaño necesario.</li>
              <li><code>DeserializationError error = deserializeJson(doc, payload);</code>: Convertimos el string JSON
                (<code>payload</code>) en una estructura de datos manejable dentro del <code>doc</code>. Si hay un error
                en
                el formato JSON, se captura aquí.</li>
              <li><code>const char* fact = doc["fact"];</code>: Accedemos directamente al valor asociado con la clave
                <code>"fact"</code> en el JSON. ArduinoJson hace que esto sea muy intuitivo.
              </li>
            </ul>
            <p>Este proceso de parseo es fundamental para trabajar con datos estructurados provenientes de APIs.</p>

            <hr class="my-4">

            <h2 class="text-primary border-bottom pb-2 mb-4">4. Proyecto Integrador: Sistema de Clima Local con Node-RED
            </h2>
            <p>Vamos a crear un proyecto más completo que combine todo lo aprendido. Este sistema leerá temperatura y
              humedad de un sensor DHT22 conectado a un ESP32, expondrá una API simple para consultar el último valor
              leído
              desde un navegador web, y enviará los datos a Node-RED, una plataforma de programación visual para el
              Internet
              de las Cosas (IoT) y más.</p>

            <h3 class="mt-4">4.1. Arquitectura del Proyecto</h3>
            <figure class="text-center my-4">
              <img src="https://placehold.co/900x500?text=Arquitectura+Proyecto+Integrador+ESP32+NodeRED"
                class="img-fluid rounded shadow-sm"
                alt="Arquitectura del proyecto integrador con ESP32, sensores, Node-RED y cliente web">
              <figcaption class="figure-caption mt-2">Arquitectura del proyecto integrador mostrando el flujo de datos
                desde
                el sensor hasta Node-RED y la visualización web.</figcaption>
            </figure>
            <ol>
              <li><strong>ESP32 (Servidor):</strong> Lee el sensor DHT22 y actúa como servidor HTTP para servir datos a
                navegadores (API de lectura) en formato HTML o JSON.</li>
              <li><strong>Navegador Web:</strong> Hace una solicitud <code>GET</code> al ESP32 para obtener el último
                valor
                de temperatura/humedad directamente.</li>
              <li><strong>ESP32 (Cliente):</strong> Actúa como cliente HTTP para enviar datos en formato JSON a un
                endpoint
                en Node-RED.</li>
              <li><strong>Node-RED:</strong> Recibe los datos del ESP32, los procesa (en este caso, simplemente los
                muestra
                en el panel de debug, pero se pueden añadir nodos para almacenarlos, graficarlos, etc.).</li>
            </ol>

            <h3 class="mt-4">4.2. Parte 1: Configurar Node-RED para recibir datos</h3>
            <p><strong>Instalación de Node-RED:</strong></p>
            <p>Node-RED es una herramienta de programación visual que se puede ejecutar en tu computadora, una Raspberry
              Pi
              o en la nube. Aquí te muestro cómo instalarlo localmente usando npm (Node Package Manager).</p>
            <ol>
              <li><strong>Instalar Node.js:</strong> Ve a <a href="https://nodejs.org/"
                  target="_blank">https://nodejs.org/</a> y descarga e instala la versión LTS para tu sistema operativo.
              </li>
              <li><strong>Instalar Node-RED:</strong> Abre una terminal o consola de comandos y ejecuta:
                <pre
                  class="bg-dark text-white p-2 rounded"><code class="language-bash">npm install -g node-red</code></pre>
              </li>
              <li><strong>Iniciar Node-RED:</strong> En la terminal, ejecuta:
                <pre class="bg-dark text-white p-2 rounded"><code class="language-bash">node-red</code></pre>
                Node-RED se iniciará y podrás acceder a su editor en tu navegador en <a href="http://localhost:1800"
                  target="_blank">http://localhost:1800</a>.
              </li>
            </ol>

            <h5 class="mt-3">Configurando un Flujo Simple en Node-RED</h5>
            <ol>
              <li><strong>Accede al Editor:</strong> Abre tu navegador y ve a <a href="http://localhost:1800"
                  target="_blank">http://localhost:1800</a>.</li>
              <li><strong>Añade un Nodo "http in":</strong>
                <ul>
                  <li>En el panel izquierdo, busca el nodo <code>http</code>.</li>
                  <li>Arrastra el nodo <code>http in</code> al flujo principal.</li>
                  <li>Haz doble clic en el nodo para configurarlo:
                    <ul>
                      <li><strong>Method:</strong> Selecciona <code>post</code>.</li>
                      <li><strong>URL:</strong> Escribe <code>/sensor-data</code>.</li>
                      <li>Haz clic en <strong>Done</strong>.</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li><strong>Añade un Nodo "Debug":</strong>
                <ul>
                  <li>Busca el nodo <code>debug</code> en el panel izquierdo.</li>
                  <li>Arrástralo al flujo.</li>
                  <li>Conecta la salida del nodo <code>http in</code> a la entrada del nodo <code>debug</code> (arrastra
                    desde un puerto a otro).</li>
                </ul>
              </li>
              <li><strong>Despliega el Flujo:</strong>
                <ul>
                  <li>Haz clic en el botón <strong>Deploy</strong> en la esquina superior derecha.</li>
                </ul>
              </li>
            </ol>
            <p>Ahora Node-RED tiene un endpoint simple (<code>http://TU_IP_LOCAL:1800/sensor-data</code>) que escucha
              solicitudes POST y muestra los datos recibidos en el panel de Debug.</p>

            <h5 class="mt-3">Materiales</h5>
            <ul>
              <li>1 Placa ESP32</li>
              <li>1 Sensor DHT22</li>
              <li>Protoboard y cables</li>
              <li>Computadora con Node.js y Node-RED instalados</li>
            </ul>

            <h5 class="mt-3">Código del Sketch (Cliente HTTP para enviar datos a Node-RED)</h5>
            <pre class="code-container"><button class="btn btn-outline-light btn-sm btn-copy-code" onclick="copyCodePrism(this)" aria-label="Copiar código"><i class="bi bi-clipboard"></i> Copiar</button><code class="language-cpp" id="nodered-client-code">/*
 * Cliente HTTP para ESP32 con DHT22
 * Lee datos del sensor y los envía a un endpoint de Node-RED.
 */

#include &lt;WiFi.h&gt;
#include &lt;HTTPClient.h&gt;
#include &lt;ArduinoJson.h&gt; // Necesitamos JSON para enviar datos estructurados
#include &lt;DHT.h&gt;

// --- Configuración de WiFi ---
const char* ssid = "TU_SSID";
const char* password = "TU_CONTRASEÑA";

// --- Configuración de Node-RED ---
// Reemplaza con la IP de la computadora donde corre Node-RED
const char* nodered_server = "http://192.168.1.100";
const int nodered_port = 1800;
String endpoint = "/sensor-data";

// --- Configuración del Sensor DHT ---
#define DHTPIN 4
#define DHTTYPE DHT22
DHT dht(DHTPIN, DHTTYPE);

void setup() {
  Serial.begin(115200);
  dht.begin();
  
  // Conectamos a la red WiFi
  Serial.print("Conectando a ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println("¡Conectado a la red WiFi!");
  Serial.print("Dirección IP del ESP32: ");
  Serial.println(WiFi.localIP());
}

void loop() {
  if (WiFi.status() == WL_CONNECTED) {
    // Leemos datos del sensor
    float h = dht.readHumidity();
    float t = dht.readTemperature();

    // Verificamos si las lecturas son válidas
    if (isnan(h) || isnan(t)) {
      Serial.println("¡Error leyendo el sensor DHT!");
      delay(10000);
      return;
    }

    Serial.print("Temperatura: ");
    Serial.print(t);
    Serial.print(" °C, Humedad: ");
    Serial.print(h);
    Serial.println(" %");

    // --- Preparamos los datos en formato JSON ---
    DynamicJsonDocument doc(256);
    doc["sensor"] = "DHT22";
    doc["temperatura"] = t;
    doc["humedad"] = h;
    doc["unidad_temp"] = "Celsius";
    doc["unidad_hum"] = "%";
    doc["timestamp"] = millis();

    String jsonData;
    serializeJson(doc, jsonData);

    // --- Enviamos datos a Node-RED ---
    HTTPClient http;
    String url = String(nodered_server) + ":" + nodered_port + endpoint;
    http.begin(url);
    http.addHeader("Content-Type", "application/json");

    int httpResponseCode = http.POST(jsonData);

    if (httpResponseCode > 0) {
      Serial.print("Código de respuesta HTTP: ");
      Serial.println(httpResponseCode);
      if (httpResponseCode == 200) {
        Serial.println("Datos enviados a Node-RED exitosamente.");
      }
    } else {
      Serial.print("Error al enviar datos. Código: ");
      Serial.println(httpResponseCode);
    }
    http.end();

  } else {
    Serial.println("Error: No conectado a WiFi");
  }

  delay(15000); // Enviamos datos cada 15 segundos
}</code></pre>

            <h3 class="mt-4">4.3. Parte 2: Exponer una API Simple desde el ESP32 (Servidor Web)</h3>
            <p>Ahora haremos que el ESP32 también actúe como un servidor web básico para servir sus propios datos.</p>

            <h5 class="mt-3">Código del Sketch (Servidor Web)</h5>
            <pre class="code-container"><button class="btn btn-outline-light btn-sm btn-copy-code" onclick="copyCodePrism(this)" aria-label="Copiar código"><i class="bi bi-clipboard"></i> Copiar</button><code class="language-cpp" id="esp32-webserver-code">/*
 * ESP32 como Servidor Web
 * Lee datos del sensor y los sirve en una página web y en formato JSON.
 */

#include &lt;WiFi.h&gt;
#include &lt;WebServer.h&gt; // Librería para el servidor web
#include &lt;DHT.h&gt;

// --- Configuración de WiFi ---
const char* ssid = "TU_SSID";
const char* password = "TU_CONTRASEÑA";

// --- Configuración del Sensor DHT ---
#define DHTPIN 4
#define DHTTYPE DHT22
DHT dht(DHTPIN, DHTTYPE);

// --- Configuración del Servidor Web ---
WebServer serverWeb(80); // El servidor escuchará en el puerto 80

// --- Variables para almacenar las últimas lecturas ---
float ultimaTemperatura = 0.0;
float ultimaHumedad = 0.0;

// --- Handler para la ruta raíz "/" ---
void handleRoot() {
  String html = "&lt;!DOCTYPE html&gt;&lt;html&gt;";
  html += "&lt;head&gt;&lt;meta charset='UTF-8'&gt;&lt;title&gt;Datos del Sensor&lt;/title&gt;";
  html += "&lt;meta name='viewport' content='width=device-width, initial-scale=1.0'&gt;";
  html += "&lt;style&gt;body{font-family: Arial, sans-serif; text-align: center; padding: 20px;}";
  html += "h1{color: #333;} .data{font-size: 24px; margin: 20px 0;}";
  html += ".temp{color: #ff6b6b;} .hum{color: #4ecdc4;}&lt;/style&gt;&lt;/head&gt;";
  html += "&lt;body&gt;";
  html += "&lt;h1&gt;Datos del Sensor DHT22&lt;/h1&gt;";
  html += "&lt;div class='data'&gt;&lt;span class='temp'&gt;Temperatura: " + String(ultimaTemperatura, 2) + " &deg;C&lt;/span&gt;&lt;/div&gt;";
  html += "&lt;div class='data'&gt;&lt;span class='hum'&gt;Humedad: " + String(ultimaHumedad, 2) + " %&lt;/span&gt;&lt;/div&gt;";
  html += "&lt;p&gt;&lt;a href='/datos'&gt;Ver datos en JSON&lt;/a&gt; | Última actualización: " + String(millis() / 1000) + "s&lt;/p&gt;";
  html += "&lt;/body&gt;&lt;/html&gt;";

  serverWeb.send(200, "text/html", html);
}

// --- Handler para la ruta "/datos" (API JSON) ---
void handleDatos() {
  String json = "{";
  json += "\"temperatura\":" + String(ultimaTemperatura, 2) + ",";
  json += "\"humedad\":" + String(ultimaHumedad, 2) + ",";
  json += "\"unidad_temp\":\"Celsius\",";
  json += "\"unidad_hum\":\"%\",";
  json += "\"timestamp\":" + String(millis());
  json += "}";
  
  // Establecemos el encabezado Content-Type para JSON
  serverWeb.sendHeader("Content-Type", "application/json");
  serverWeb.send(200, "application/json", json);
}

void setup() {
  Serial.begin(115200);
  dht.begin();

  // Conectamos a la red WiFi
  Serial.print("Conectando a ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println("¡Conectado a la red WiFi!");
  Serial.print("Dirección IP: ");
  Serial.println(WiFi.localIP());

  // --- Configuramos las rutas del servidor web ---
  serverWeb.on("/", handleRoot);    // Página principal HTML
  serverWeb.on("/datos", handleDatos); // API JSON
  serverWeb.onNotFound([]() {       // Página 404 para rutas no definidas
    serverWeb.send(404, "text/plain", "Página no encontrada");
  });

  // --- Iniciamos el servidor ---
  serverWeb.begin();
  Serial.println("Servidor HTTP iniciado");
}

void loop() {
  // --- Manejamos las solicitudes entrantes al servidor ---
  serverWeb.handleClient();

  // --- Lógica de lectura de datos (cada 5 segundos) ---
  static unsigned long lastRead = 0;
  if (millis() - lastRead > 5000) {
    lastRead = millis();

    // Leemos datos del sensor
    float h = dht.readHumidity();
    float t = dht.readTemperature();

    if (!isnan(h) && !isnan(t)) {
      ultimaTemperatura = t;
      ultimaHumedad = h;
      
      Serial.print("Temperatura: ");
      Serial.print(t);
      Serial.print(" °C, Humedad: ");
      Serial.print(h);
      Serial.println(" %");
    } else {
      Serial.println("¡Error leyendo el sensor DHT!");
    }
  }
}</code></pre>

            <h5 class="mt-3">Explicación del Código del Servidor</h5>
            <ul>
              <li><code>#include &lt;WebServer.h&gt;</code>: Incluimos la librería para crear un servidor web.</li>
              <li><code>WebServer serverWeb(80);</code>: Creamos un objeto servidor que escuchará en el puerto 80
                (puerto
                estándar para HTTP).</li>
              <li><code>serverWeb.on("/", handleRoot);</code>: Definimos una "ruta". Cuando alguien accede a
                <code>http://IP_DEL_ESP32/</code>, se ejecutará la función <code>handleRoot</code>.
              </li>
              <li><code>handleRoot()</code> y <code>handleDatos()</code>: Son funciones "handler" que definen qué
                contenido
                se debe servir para cada ruta. <code>handleRoot</code> genera una página HTML simple, mientras que
                <code>handleDatos</code> genera una respuesta JSON.
              </li>
              <li><code>serverWeb.begin();</code>: Inicia el servidor web.</li>
              <li><code>serverWeb.handleClient();</code>: Esta línea en el <code>loop()</code> es crucial. Le dice al
                servidor que revise si hay nuevas solicitudes de clientes web y las procese.</li>
            </ul>

            <h5 class="mt-3">Cómo Probarlo</h5>
            <ol>
              <li>Carga el sketch del servidor en tu ESP32.</li>
              <li>Abre el Monitor Serial para ver la dirección IP asignada (por ejemplo, <code>192.168.1.120</code>).
              </li>
              <li>Abre un navegador web en un dispositivo conectado a la misma red WiFi.</li>
              <li>Ingresa la dirección IP en la barra de direcciones:
                <ul>
                  <li><code>http://192.168.1.120/</code> te mostrará la página web con los datos.</li>
                  <li><code>http://192.168.1.120/datos</code> te devolverá los datos en formato JSON.</li>
                </ul>
              </li>
              <li>Ejecuta el flujo de Node-RED y carga el sketch del cliente ESP32. Abre el panel de Debug en Node-RED
                para
                ver los datos que llegan desde el ESP32.</li>
            </ol>
            <p>Este proyecto demuestra cómo un microcontrolador puede servir sus propios datos a través de una API web
              simple y cómo otro dispositivo (Node-RED en este caso) puede consumir esos datos.</p>

            <hr class="my-4">

            <h2 class="text-primary border-bottom pb-2 mb-4">5. Otras Plataformas y Servicios Populares</h2>
            <p>Además de las herramientas vistas, existen muchas otras plataformas que facilitan la integración con APIs
              y
              el desarrollo de aplicaciones IoT.</p>

            <div class="row row-cols-1 row-cols-md-2 g-4">
              <div class="col">
                <div class="card h-100 shadow-sm">
                  <div class="card-body">
                    <h5 class="card-title">Blynk</h5>
                    <p>Una plataforma que permite crear interfaces de usuario móviles (apps) para controlar y monitorear
                      dispositivos mediante "widgets" arrastrables. Se comunica con el dispositivo a través de su propio
                      servidor y app.</p>
                    <a href="https://blynk.io/" class="btn btn-outline-primary btn-sm" target="_blank">Sitio Oficial</a>
                  </div>
                </div>
              </div>
              <div class="col">
                <div class="card h-100 shadow-sm">
                  <div class="card-body">
                    <h5 class="card-title">Ubidots</h5>
                    <p>Plataforma empresarial para IoT que ofrece herramientas de visualización, análisis y creación de
                      aplicaciones. Proporciona librerías específicas para ESP32/Arduino.</p>
                    <a href="https://ubidots.com/" class="btn btn-outline-primary btn-sm" target="_blank">Sitio
                      Oficial</a>
                  </div>
                </div>
              </div>
              <div class="col">
                <div class="card h-100 shadow-sm">
                  <div class="card-body">
                    <h5 class="card-title">Firebase</h5>
                    <p>Plataforma de Google para desarrollo de apps que incluye una base de datos en tiempo real
                      (Realtime
                      Database) y autenticación. Excelente para crear aplicaciones web y móviles que se sincronicen
                      instantáneamente con tu dispositivo.</p>
                    <a href="https://firebase.google.com/" class="btn btn-outline-primary btn-sm" target="_blank">Sitio
                      Oficial</a>
                  </div>
                </div>
              </div>
              <div class="col">
                <div class="card h-100 shadow-sm">
                  <div class="card-body">
                    <h5 class="card-title">ThingSpeak</h5>
                    <p>Plataforma de análisis de datos IoT que permite almacenar, visualizar y analizar datos de
                      dispositivos conectados. Proporciona APIs sencillas para la integración.</p>
                    <a href="https://thingspeak.com/" class="btn btn-outline-primary btn-sm" target="_blank">Sitio
                      Oficial</a>
                  </div>
                </div>
              </div>
            </div>

            <hr class="my-4">

            <h2 class="text-primary border-bottom pb-2 mb-4">6. Galería de Videos Recomendados</h2>
            <div class="row row-cols-1 row-cols-md-2 g-4">
              <div class="col">
                <div class="card h-100 shadow-sm">
                  <div class="ratio ratio-16x9">
                    <iframe src="https://www.youtube.com/embed/ZXmPbrf8K2c" title="YouTube video player" frameborder="0"
                      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                      allowfullscreen></iframe>
                  </div>
                  <div class="card-body">
                    <h5 class="card-title">¿Qué es una API? (Explicación Sencilla)</h5>
                    <p class="card-text">Una introducción clara y sencilla a qué es una API y por qué son importantes.
                    </p>
                  </div>
                </div>
              </div>
              <div class="col">
                <div class="card h-100 shadow-sm">
                  <div class="ratio ratio-16x9">
                    <iframe src="https://www.youtube.com/embed/31rX8MvG14o" title="YouTube video player" frameborder="0"
                      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                      allowfullscreen></iframe>
                  </div>
                  <div class="card-body">
                    <h5 class="card-title">ESP32 HTTP GET y POST con Arduino IDE</h5>
                    <p class="card-text">Tutorial práctico sobre cómo realizar solicitudes HTTP GET y POST desde un
                      ESP32.
                    </p>
                  </div>
                </div>
              </div>
            </div>

            <hr class="my-4">

            <h2 class="text-primary border-bottom pb-2 mb-4">7. Referencias y Lecturas Recomendadas</h2>
            <ul class="list-group">
              <li class="list-group-item"><a href="https://arduinojson.org/" target="_blank">Documentación de
                  ArduinoJson</a> - La guía oficial y herramientas para trabajar con JSON en Arduino/ESP.</li>
              <li class="list-group-item"><a href="https://randomnerdtutorials.com/esp32-http-get-post-arduino/"
                  target="_blank">Random Nerd Tutorials: ESP32 HTTP GET and POST</a> - Tutoriales prácticos y muy bien
                explicados.</li>
              <li class="list-group-item"><a href="https://thingspeak.com/" target="_blank">ThingSpeak</a> - Plataforma
                de
                análisis de datos IoT con documentación y ejemplos.</li>
              <li class="list-group-item">Fielding, R., &amp; Reschke, J. (2014). <em>RFC 7231: Hypertext Transfer
                  Protocol
                  (HTTP/1.1): Semantics and Content</em>. IETF. (Especificación oficial de HTTP, base de las REST APIs).
              </li>
            </ul>

          </section>
        </article>
      </div>
    </div>

    <!-- Sequential Navigation -->
    <nav class="d-flex justify-content-between mt-4">
      <a href="protocolo-mqtt.html" class="btn btn-primary">&larr; Tema Anterior</a>
      <a href="../fundamentos-de-mecatronica.html" class="btn btn-primary">Finalizar Formación &rarr;</a>
    </nav>

    <footer class="mt-5 text-center">
      <a href="../fundamentos-de-mecatronica.html" class="btn btn-secondary">Volver al Temario</a>
    </footer>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
    crossorigin="anonymous"></script>
  <!-- Prism.js JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

  <!-- Script para copiar código -->
  <script>
    function copyCodePrism(button) {
      const codeElement = button.nextElementSibling || button.parentElement.querySelector('code');
      if (codeElement) {
        const codeText = codeElement.textContent;
        navigator.clipboard.writeText(codeText).then(() => {
          const originalHTML = button.innerHTML;
          button.innerHTML = '<i class="bi bi-check"></i> ¡Copiado!';
          button.classList.remove('btn-outline-light');
          button.classList.add('btn-success');
          setTimeout(() => {
            button.innerHTML = originalHTML;
            button.classList.remove('btn-success');
            button.classList.add('btn-outline-light');
          }, 2000);
        }).catch(err => {
          console.error('Error al copiar el texto: ', err);
          alert('Error al copiar el código. Por favor, inténtalo manualmente.');
        });
      } else {
        console.error('No se pudo encontrar el elemento de código para copiar.');
      }
    }
  </script>
</body>

</html>